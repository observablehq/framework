import assert, {fail} from "node:assert";
import {Readable, Writable} from "node:stream";
import {normalizeConfig} from "../src/config.js";
import type {DeployEffects} from "../src/deploy.js";
import {deploy} from "../src/deploy.js";
import {isHttpError} from "../src/error.js";
import type {Logger} from "../src/logger.js";
import {commandRequiresAuthenticationMessage} from "../src/observableApiAuth.js";
import type {DeployConfig} from "../src/observableApiConfig.js";
import {MockLogger} from "./mocks/logger.js";
import {ObservableApiMock} from "./mocks/observableApi.js";
import {invalidApiKey, userWithTwoWorkspaces, userWithZeroWorkspaces, validApiKey} from "./mocks/observableApi.js";

// These files are implicitly generated by the CLI. This may change over time,
// so theyâ€™re enumerated here for clarity. TODO We should enforce that these
// files are specifically uploaded, rather than just the number of files.
const EXTRA_FILES: string[] = [
  "_observablehq/client.js",
  "_observablehq/runtime.js",
  "_observablehq/stdlib.js",
  "_observablehq/stdlib/dash.js",
  "_observablehq/stdlib/dot.js",
  "_observablehq/stdlib/duckdb.js",
  "_observablehq/stdlib/mermaid.js",
  "_observablehq/stdlib/sqlite.js",
  "_observablehq/stdlib/tex.js",
  "_observablehq/stdlib/xlsx.js",
  "_observablehq/stdlib/zip.js",
  "_observablehq/style.css"
];

class MockDeployEffects implements DeployEffects {
  public logger = new MockLogger();
  public input = new Readable();
  public output: NodeJS.WritableStream;
  public observableApiKey: string | null = null;
  public deployConfig: DeployConfig | null = null;
  public projectTitle = "My Project";
  public projectSlug = "my-project";
  public deployMessage = "fix some bugs";

  constructor({
    apiKey = validApiKey,
    deployConfig = null
  }: {apiKey?: string | null; deployConfig?: DeployConfig | null} = {}) {
    this.observableApiKey = apiKey;
    this.deployConfig = deployConfig;
    const that = this;
    this.output = new Writable({
      write(data, _enc, callback) {
        const dataString = data.toString();
        if (dataString == "New project title: ") {
          that.input.push(`${that.projectTitle}\n`);
          // Having to null/reinit input seems wrong.
          // TODO: find the correct way to submit to readline but keep the same
          // input stream across multiple readline interactions.
          that.input.push(null);
          that.input = new Readable();
        } else if (dataString.match(/^New project slug \[.*\]: $/)) {
          that.input.push(`${that.projectSlug}\n`);
          that.input.push(null);
          that.input = new Readable();
        } else if (dataString == "Deploy message: ") {
          that.input.push(`${that.deployMessage}\n`);
          that.input.push(null);
          that.input = new Readable();
        } else if (dataString.includes("Choice: ")) {
          that.input.push("1\n");
          that.input.push(null);
          that.input = new Readable();
        }
        callback();
      }
    });
  }

  async getObservableApiKey(logger: Logger) {
    if (!this.observableApiKey) {
      logger.log(commandRequiresAuthenticationMessage);
      throw new Error("no key available in this test");
    }
    return {source: "test" as const, key: this.observableApiKey};
  }

  async getDeployConfig() {
    return this.deployConfig;
  }

  async setDeployConfig(sourceRoot: string, config: DeployConfig) {
    this.deployConfig = config;
  }
}

// This test should have exactly one index.md in it, and nothing else; that one
// page is why we +1 to the number of extra files.
const TEST_SOURCE_ROOT = "test/input/build/simple-public";
const TEST_CONFIG = await normalizeConfig({root: TEST_SOURCE_ROOT});

// TODO These tests need mockJsDelivr, too!
describe("deploy", () => {
  it("makes expected API calls for a new project", async () => {
    const projectId = "project123";
    const deployId = "deploy456";
    const apiMock = new ObservableApiMock()
      .handleGetUser()
      .handlePostProject({projectId})
      .handlePostDeploy({projectId, deployId})
      .handlePostDeployFile({deployId, repeat: EXTRA_FILES.length + 1})
      .handlePostDeployUploaded({deployId})
      .start();

    const effects = new MockDeployEffects();
    await deploy({config: TEST_CONFIG}, effects);

    apiMock.close();
    const deployConfig = await effects.getDeployConfig();
    assert.equal(deployConfig?.project?.id, projectId);
    assert.equal(deployConfig?.project?.slug, effects.projectSlug);
  });

  it("makes expected API calls for an existing project", async () => {
    const projectId = "project123";
    const deployConfig = {project: {id: projectId}};
    const deployId = "deploy456";
    const apiMock = new ObservableApiMock()
      .handlePostDeploy({projectId, deployId})
      .handlePostDeployFile({deployId, repeat: EXTRA_FILES.length + 1})
      .handlePostDeployUploaded({deployId})
      .start();

    const effects = new MockDeployEffects({deployConfig});
    await deploy({config: TEST_CONFIG}, effects);

    apiMock.close();
  });

  it("shows message for missing API key", async () => {
    const apiMock = new ObservableApiMock().start();
    const effects = new MockDeployEffects({apiKey: null});

    try {
      await deploy({config: TEST_CONFIG}, effects);
      assert.fail("expected error");
    } catch (err) {
      if (!(err instanceof Error)) throw err;
      assert.equal(err.message, "no key available in this test");
      effects.logger.assertExactLogs([/^You need to be authenticated/]);
    }

    apiMock.close();
  });

  it("handles multiple user workspaces", async () => {
    const projectId = "project123";
    const deployId = "deploy456";
    const apiMock = new ObservableApiMock()
      .handleGetUser({user: userWithTwoWorkspaces})
      .handlePostProject({projectId})
      .handlePostDeploy({projectId, deployId})
      .handlePostDeployFile({deployId, repeat: EXTRA_FILES.length + 1})
      .handlePostDeployUploaded({deployId})
      .start();
    const effects = new MockDeployEffects();

    await deploy({config: TEST_CONFIG}, effects);

    apiMock.close();
    const deployConfig = await effects.getDeployConfig();
    assert.equal(deployConfig?.project?.id, projectId);
    assert.equal(deployConfig?.project?.slug, effects.projectSlug);
  });

  it("logs an error during project creation when user has no workspaces", async () => {
    const apiMock = new ObservableApiMock().handleGetUser({user: userWithZeroWorkspaces}).start();
    const effects = new MockDeployEffects();

    await deploy({config: TEST_CONFIG}, effects);

    apiMock.close();
    effects.logger.assertExactErrors([/^Current user doesn't have any Observable workspaces/]);
  });

  it("throws an error with an invalid API key", async () => {
    const apiMock = new ObservableApiMock().handleGetUser({status: 401}).start();
    const effects = new MockDeployEffects({apiKey: invalidApiKey});

    try {
      await deploy({config: TEST_CONFIG}, effects);
      assert.fail("Should have thrown");
    } catch (error) {
      assert.ok(isHttpError(error));
      assert.equal(error.statusCode, 401);
    }

    apiMock.close();
  });

  it("throws an error if project creation fails", async () => {
    const apiMock = new ObservableApiMock().handleGetUser().handlePostProject({status: 500}).start();
    const effects = new MockDeployEffects();

    try {
      await deploy({config: TEST_CONFIG}, effects);
      fail("Should have thrown an error");
    } catch (error) {
      assert.ok(isHttpError(error));
      assert.equal(error.statusCode, 500);
    }

    apiMock.close();
  });

  it("throws an error if deploy creation fails", async () => {
    const projectId = "project123";
    const deployId = "deploy456";
    const apiMock = new ObservableApiMock()
      .handleGetUser()
      .handlePostProject({projectId})
      .handlePostDeploy({projectId, deployId, status: 500})
      .start();
    const effects = new MockDeployEffects();

    try {
      await deploy({config: TEST_CONFIG}, effects);
      fail("Should have thrown an error");
    } catch (error) {
      assert.ok(isHttpError(error));
      assert.equal(error.statusCode, 500);
    }

    apiMock.close();
  });

  it("throws an error if file upload fails", async () => {
    const projectId = "project123";
    const deployId = "deploy456";
    const apiMock = new ObservableApiMock()
      .handleGetUser()
      .handlePostProject({projectId})
      .handlePostDeploy({projectId, deployId})
      .handlePostDeployFile({deployId, status: 500})
      .start();
    const effects = new MockDeployEffects();

    try {
      await deploy({config: TEST_CONFIG}, effects);
      fail("Should have thrown an error");
    } catch (error) {
      assert.ok(isHttpError(error));
      assert.equal(error.statusCode, 500);
    }

    apiMock.close();
  });

  it("throws an error if deploy uploaded fails", async () => {
    const projectId = "project123";
    const deployId = "deploy456";
    const apiMock = new ObservableApiMock()
      .handleGetUser()
      .handlePostProject({projectId})
      .handlePostDeploy({projectId, deployId})
      .handlePostDeployFile({deployId, repeat: EXTRA_FILES.length + 1})
      .handlePostDeployUploaded({deployId, status: 500})
      .start();
    const effects = new MockDeployEffects();

    try {
      await deploy({config: TEST_CONFIG}, effects);
      fail("Should have thrown an error");
    } catch (error) {
      assert.ok(isHttpError(error));
      assert.equal(error.statusCode, 500);
    }

    apiMock.close();
  });
});
