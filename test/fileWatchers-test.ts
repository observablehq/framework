import assert from "node:assert";
import {renameSync, unlinkSync, utimesSync, writeFileSync} from "node:fs";
import {InternSet, difference} from "d3-array";
import {FileWatchers} from "../src/fileWatchers.js";

describe("FileWatchers.of(root, path, names, callback)", () => {
  const root = "test/input/build/files";
  it("watches a file", async () => {
    const [watcher, watches] = await useWatcher(root, "files.md", ["file-top.csv"]);
    try {
      touch("test/input/build/files/file-top.csv");
      assert.deepStrictEqual(await watches(), ["file-top.csv"]);
    } finally {
      watcher.close();
    }
  });
  it("watches multiple files", async () => {
    const [watcher, watches] = await useWatcher(root, "files.md", ["file-top.csv", "subsection/file-sub.csv"]);
    try {
      touch("test/input/build/files/file-top.csv");
      touch("test/input/build/files/subsection/file-sub.csv");
      assert.deepStrictEqual(await watches(), ["file-top.csv", "subsection/file-sub.csv"]);
    } finally {
      watcher.close();
    }
  });
  it("watches a file generated by a data loader", async () => {
    const [watcher, watches] = await useWatcher("test/input/build/simple", "simple.md", ["data.txt"]);
    try {
      touch("test/input/build/simple/data.txt.js");
      assert.deepStrictEqual(await watches(), ["data.txt"]);
    } finally {
      watcher.close();
    }
  });
  it("watches a file within a static archive", async () => {
    const [watcher, watches] = await useWatcher("test/input/build/archives.posix", "zip.md", ["static/file.txt"]);
    try {
      touch("test/input/build/archives.posix/static.zip");
      assert.deepStrictEqual(await watches(), ["static/file.txt"]);
    } finally {
      watcher.close();
    }
  });
  it("watches a file within an archive created by a data loader", async () => {
    const [watcher, watches] = await useWatcher("test/input/build/archives.posix", "zip.md", ["dynamic/file.txt"]);
    try {
      touch("test/input/build/archives.posix/dynamic.zip.sh");
      assert.deepStrictEqual(await watches(), ["dynamic/file.txt"]);
    } finally {
      watcher.close();
    }
  });
  it("deduplicates watched files", async () => {
    const [watcher, watches] = await useWatcher(root, "files.md", ["file-top.csv", "file-top.csv"]);
    try {
      touch("test/input/build/files/file-top.csv");
      assert.deepStrictEqual(await watches(), ["file-top.csv"]);
    } finally {
      watcher.close();
    }
  });
  it("deduplicates watched files based on name, not normalized path", async () => {
    const [watcher, watches] = await useWatcher(root, "files.md", ["file-top.csv", "./file-top.csv"]);
    try {
      touch("test/input/build/files/file-top.csv");
      assert.deepStrictEqual(await watches(), ["./file-top.csv", "file-top.csv"]);
    } finally {
      watcher.close();
    }
  });
  it("resolves relative paths", async () => {
    const [watcher, watches] = await useWatcher(root, "subsection/subfiles.md", ["./file-sub.csv", "../file-top.csv"]);
    try {
      touch("test/input/build/files/file-top.csv");
      assert.deepStrictEqual(await watches(), ["../file-top.csv"]);
    } finally {
      watcher.close();
    }
  });
  it("resolves absolute paths", async () => {
    const [watcher, watches] = await useWatcher(root, "subsection/subfiles.md", ["/file-top.csv"]);
    try {
      touch("test/input/build/files/file-top.csv");
      assert.deepStrictEqual(await watches(), ["/file-top.csv"]);
    } finally {
      watcher.close();
    }
  });
  it("ignores missing files", async () => {
    const [watcher, watches] = await useWatcher(root, "files.md", ["does-not-exist.csv", "file-top.csv"]);
    try {
      touch("test/input/build/files/file-top.csv");
      assert.deepStrictEqual(await watches(), ["file-top.csv"]);
    } finally {
      watcher.close();
    }
  });
  it("ignores changes that don’t affect the modification time", async () => {
    const then = new Date();
    touch("test/input/build/files/file-top.csv", then);
    const [watcher, watches] = await useWatcher(root, "files.md", ["file-top.csv"]);
    try {
      touch("test/input/build/files/file-top.csv", then);
      assert.deepStrictEqual(await watches(10), []);
    } finally {
      watcher.close();
    }
  });
  it("ignores changes to empty files", async () => {
    const then = new Date();
    const [watcher, watches] = await useWatcher("test/input", "comment.md", ["empty.js"]);
    try {
      touch("test/input/empty.js", then);
      assert.deepStrictEqual(await watches(10), []);
    } finally {
      watcher.close();
    }
  });
  it("handles a file being renamed", async () => {
    writeFileSync("test/input/build/files/temp.csv", "hello", "utf-8");
    try {
      const [watcher, watches] = await useWatcher(root, "files.md", ["temp.csv"]);
      try {
        // First rename the file, while writing a new file to the same place.
        renameSync("test/input/build/files/temp.csv", "test/input/build/files/temp2.csv");
        writeFileSync("test/input/build/files/temp.csv", "hello 2", "utf-8");
        assert.deepStrictEqual(await watches(), ["temp.csv"]);

        // Then test that writing to the original location watches the new file.
        writeFileSync("test/input/build/files/temp.csv", "hello 3", "utf-8");
        assert.deepStrictEqual(await watches(), ["temp.csv"]);
      } finally {
        watcher.close();
      }
    } finally {
      cleanupSync("test/input/build/files/temp.csv");
      cleanupSync("test/input/build/files/temp2.csv");
    }
  });
  it("handles a file being renamed and removed", async () => {
    writeFileSync("test/input/build/files/temp.csv", "hello", "utf-8");
    try {
      const [watcher, watches] = await useWatcher(root, "files.md", ["file-top.csv", "temp.csv"]);
      try {
        // First delete the temp file. We don’t care if this is reported as a change or not.
        unlinkSync("test/input/build/files/temp.csv");
        await pause();

        // Then touch a different file to make sure the watcher is still alive.
        touch("test/input/build/files/file-top.csv");
        assert.deepStrictEqual(difference(await watches(), ["temp.csv"]), new InternSet(["file-top.csv"]));
      } finally {
        watcher.close();
      }
    } finally {
      cleanupSync("test/input/build/files/temp.csv");
    }
  });
});

async function useWatcher(
  root: string,
  path: string,
  names: string[]
): Promise<[watcher: FileWatchers, wait: (delay?: number) => Promise<string[]>]> {
  let watches = new Set<string>();
  let resume: ((value: string[]) => void) | null = null;
  const wait = (delay?: number) => {
    if (resume) throw new Error("already waiting");
    const promise = new Promise<string[]>((y) => (resume = y));
    if (delay == null) return promise;
    const timeout = new Promise<string[]>((y) => setTimeout(() => y([...watches].sort()), delay));
    return Promise.race([promise, timeout]);
  };
  const watch = (name: string) => {
    watches.add(name);
    const r = resume;
    if (r == null) return;
    resume = null;
    setTimeout(() => (r([...watches].sort()), (watches = new Set<string>())), 10);
  };
  const watcher = await FileWatchers.of(root, path, names, watch);
  await pause();
  return [watcher, wait];
}

async function pause(): Promise<void> {
  await new Promise((resolve) => setTimeout(resolve, 10));
}

function touch(path: string, date = new Date()): void {
  utimesSync(path, date, date);
}

function cleanupSync(path: string): void {
  try {
    unlinkSync(path);
  } catch {
    // ignore
  }
}
