import assert from "node:assert";
import {utimesSync} from "node:fs";
import {FileWatchers} from "../src/fileWatchers.js";

describe("FileWatchers.of(root, path, names, callback)", () => {
  const root = "test/input/build/files";
  it("watches a file", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of(root, "files.md", ["file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      await pause();
      assert.deepStrictEqual(names, new Set(["file-top.csv"]));
    } finally {
      watcher.close();
    }
  });
  it("watches multiple files", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of(root, "files.md", ["file-top.csv", "subsection/file-sub.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      touch("test/input/build/files/subsection/file-sub.csv");
      await pause();
      assert.deepStrictEqual(names, new Set(["file-top.csv", "subsection/file-sub.csv"]));
    } finally {
      watcher.close();
    }
  });
  it("watches a file generated by a data loader", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of("test/input/build/simple", "simple.md", ["data.txt"], watch);
    try {
      await pause();
      touch("test/input/build/simple/data.txt.sh");
      await pause();
      assert.deepStrictEqual(names, new Set(["data.txt"]));
    } finally {
      watcher.close();
    }
  });
  it("watches a file within a static archive", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of("test/input/build/archives", "zip.md", ["static/file.txt"], watch);
    try {
      await pause();
      touch("test/input/build/archives/static.zip");
      await pause();
      assert.deepStrictEqual(names, new Set(["static/file.txt"]));
    } finally {
      watcher.close();
    }
  });
  it("watches a file within an archive created by a data loader", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of("test/input/build/archives", "zip.md", ["dynamic/file.txt"], watch);
    try {
      await pause();
      touch("test/input/build/archives/dynamic.zip.sh");
      await pause();
      assert.deepStrictEqual(names, new Set(["dynamic/file.txt"]));
    } finally {
      watcher.close();
    }
  });
  it("deduplicates watched files", async () => {
    const names: string[] = [];
    const watch = (name: string) => names.push(name);
    const watcher = await FileWatchers.of(root, "files.md", ["file-top.csv", "file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      await pause();
      assert.deepStrictEqual(names, ["file-top.csv"]);
    } finally {
      watcher.close();
    }
  });
  it("deduplicates watched files based on name, not normalized path", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of(root, "files.md", ["file-top.csv", "./file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      await pause();
      assert.deepStrictEqual(names, new Set(["file-top.csv", "./file-top.csv"]));
    } finally {
      watcher.close();
    }
  });
  it("resolves relative paths", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of(root, "subsection/subfiles.md", ["./file-sub.csv", "../file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      await pause();
      assert.deepStrictEqual(names, new Set(["../file-top.csv"]));
    } finally {
      watcher.close();
    }
  });
  it("resolves absolute paths", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of(root, "subsection/subfiles.md", ["/file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      await pause();
      assert.deepStrictEqual(names, new Set(["/file-top.csv"]));
    } finally {
      watcher.close();
    }
  });
  it("ignores missing files", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of(root, "files.md", ["does-not-exist.csv", "file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      await pause();
      assert.deepStrictEqual(names, new Set(["file-top.csv"]));
    } finally {
      watcher.close();
    }
  });
  it("ignores changes that donâ€™t affect the modification time", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const then = new Date();
    touch("test/input/build/files/file-top.csv", then);
    const watcher = await FileWatchers.of(root, "files.md", ["file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv", then);
      await pause();
      assert.deepStrictEqual(names, new Set());
    } finally {
      watcher.close();
    }
  });
  it("ignores changes to empty files", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const then = new Date();
    const watcher = await FileWatchers.of("test/input", "comment.md", ["empty.js"], watch);
    try {
      await pause();
      touch("test/input/empty.js", then);
      await pause();
      assert.deepStrictEqual(names, new Set());
    } finally {
      watcher.close();
    }
  });
});

async function pause(): Promise<void> {
  await new Promise((resolve) => setTimeout(resolve, 10));
}

function touch(path: string, date = new Date()): void {
  utimesSync(path, date, date);
}
