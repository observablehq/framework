import assert from "node:assert";
import {renameSync, unlinkSync, utimesSync, writeFileSync} from "node:fs";
import {FileWatchers} from "../src/fileWatchers.js";

describe("FileWatchers.of(root, path, names, callback)", () => {
  const root = "test/input/build/files";
  it("watches a file", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of(root, "files.md", ["file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      await pause();
      assert.deepStrictEqual(names, new Set(["file-top.csv"]));
    } finally {
      watcher.close();
    }
  });
  it("watches multiple files", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of(root, "files.md", ["file-top.csv", "subsection/file-sub.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      touch("test/input/build/files/subsection/file-sub.csv");
      await pause();
      assert.deepStrictEqual(names, new Set(["file-top.csv", "subsection/file-sub.csv"]));
    } finally {
      watcher.close();
    }
  });
  it("watches a file generated by a data loader", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of("test/input/build/simple", "simple.md", ["data.txt"], watch);
    try {
      await pause();
      touch("test/input/build/simple/data.txt.sh");
      await pause();
      assert.deepStrictEqual(names, new Set(["data.txt"]));
    } finally {
      watcher.close();
    }
  });
  it("watches a file within a static archive", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of("test/input/build/archives", "zip.md", ["static/file.txt"], watch);
    try {
      await pause();
      touch("test/input/build/archives/static.zip");
      await pause();
      assert.deepStrictEqual(names, new Set(["static/file.txt"]));
    } finally {
      watcher.close();
    }
  });
  it("watches a file within an archive created by a data loader", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of("test/input/build/archives", "zip.md", ["dynamic/file.txt"], watch);
    try {
      await pause();
      touch("test/input/build/archives/dynamic.zip.sh");
      await pause();
      assert.deepStrictEqual(names, new Set(["dynamic/file.txt"]));
    } finally {
      watcher.close();
    }
  });
  it("deduplicates watched files", async () => {
    const names: string[] = [];
    const watch = (name: string) => names.push(name);
    const watcher = await FileWatchers.of(root, "files.md", ["file-top.csv", "file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      await pause();
      assert.deepStrictEqual(names, ["file-top.csv"]);
    } finally {
      watcher.close();
    }
  });
  it("deduplicates watched files based on name, not normalized path", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of(root, "files.md", ["file-top.csv", "./file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      await pause();
      assert.deepStrictEqual(names, new Set(["file-top.csv", "./file-top.csv"]));
    } finally {
      watcher.close();
    }
  });
  it("resolves relative paths", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of(root, "subsection/subfiles.md", ["./file-sub.csv", "../file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      await pause();
      assert.deepStrictEqual(names, new Set(["../file-top.csv"]));
    } finally {
      watcher.close();
    }
  });
  it("resolves absolute paths", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of(root, "subsection/subfiles.md", ["/file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      await pause();
      assert.deepStrictEqual(names, new Set(["/file-top.csv"]));
    } finally {
      watcher.close();
    }
  });
  it("ignores missing files", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const watcher = await FileWatchers.of(root, "files.md", ["does-not-exist.csv", "file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv");
      await pause();
      assert.deepStrictEqual(names, new Set(["file-top.csv"]));
    } finally {
      watcher.close();
    }
  });
  it("ignores changes that don’t affect the modification time", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const then = new Date();
    touch("test/input/build/files/file-top.csv", then);
    const watcher = await FileWatchers.of(root, "files.md", ["file-top.csv"], watch);
    try {
      await pause();
      touch("test/input/build/files/file-top.csv", then);
      await pause();
      assert.deepStrictEqual(names, new Set());
    } finally {
      watcher.close();
    }
  });
  it("ignores changes to empty files", async () => {
    const names = new Set<string>();
    const watch = (name: string) => names.add(name);
    const then = new Date();
    const watcher = await FileWatchers.of("test/input", "comment.md", ["empty.js"], watch);
    try {
      await pause();
      touch("test/input/empty.js", then);
      await pause();
      assert.deepStrictEqual(names, new Set());
    } finally {
      watcher.close();
    }
  });
  it("handles a file being renamed", async () => {
    let names: Set<string>;
    const watch = (name: string) => names.add(name);
    try {
      writeFileSync("test/input/build/files/temp.csv", "hello", "utf-8");
      const watcher = await FileWatchers.of(root, "files.md", ["temp.csv"], watch);
      try {
        // First rename the file, while writing a new file to the same place.
        names = new Set<string>();
        await pause();
        renameSync("test/input/build/files/temp.csv", "test/input/build/files/temp2.csv");
        writeFileSync("test/input/build/files/temp.csv", "hello 2", "utf-8");
        await pause(150); // avoid debounce
        assert.deepStrictEqual(names, new Set(["temp.csv"]));

        // Then test that writing to the original location watches the new file.
        names = new Set<string>();
        await pause();
        writeFileSync("test/input/build/files/temp.csv", "hello 3", "utf-8");
        await pause();
        assert.deepStrictEqual(names, new Set(["temp.csv"]));
      } finally {
        watcher.close();
      }
    } finally {
      cleanupSync("test/input/build/files/temp.csv");
      cleanupSync("test/input/build/files/temp2.csv");
    }
  });
  it("handles a file being renamed and removed", async () => {
    let names: Set<string>;
    const watch = (name: string) => names.add(name);
    try {
      writeFileSync("test/input/build/files/temp.csv", "hello", "utf-8");
      const watcher = await FileWatchers.of(root, "files.md", ["file-top.csv", "temp.csv"], watch);
      try {
        // First delete the temp file. We don’t care if this is reported as a change or not.
        names = new Set<string>();
        await pause();
        unlinkSync("test/input/build/files/temp.csv");
        await pause(150);

        // Then touch a different file to make sure the watcher is still alive.
        names = new Set<string>();
        touch("test/input/build/files/file-top.csv");
        await pause();
        assert.deepStrictEqual(names, new Set(["file-top.csv"]));
      } finally {
        watcher.close();
      }
    } finally {
      cleanupSync("test/input/build/files/temp.csv");
    }
  });
});

async function pause(delay = 10): Promise<void> {
  await new Promise((resolve) => setTimeout(resolve, delay));
}

function touch(path: string, date = new Date()): void {
  utimesSync(path, date, date);
}

function cleanupSync(path: string): void {
  try {
    unlinkSync(path);
  } catch {
    // ignore
  }
}
