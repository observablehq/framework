# Markdown reference

See [GitHub’s guide to Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) for an introduction.

## JavaScript in Markdown

In addition to standard Markdown features — headings, formatting, tables, images, and the like — Observable Markdown supports [reactive JavaScript](./javascript) that runs on the client. Live JavaScript can be expressed either as [fenced code blocks](#fenced-code-blocks) (<code>```js</code>) or [inline expressions](#inline-expressions) (<code>$\{…}</code>).

### Fenced code blocks

JavaScript fenced code blocks are typically used to display content such as charts and inputs. They can also declare top-level variables, say to load data or declare helper functions. An expression code block looks like this (note the lack of semicolon):

````md
```js
1 + 2
```
````

This produces:

```js
1 + 2
```

If the expression evaluates to a DOM node, the node is displayed. For example, here is an SVG element generated by [Observable Plot](https://observablehq.com/plot):

````md
```js
Plot.lineY(aapl, {x: "Date", y: "Close"}).plot({y: {grid: true}})
```
````

This produces:

```js
Plot.lineY(aapl, {x: "Date", y: "Close"}).plot({y: {grid: true}})
```

A program code block looks like this:

````md
```js
const x = 1 + 2;
```
````

```js
const x = 1 + 2;
```

A program code block doesn’t display anything by default, but you can call the built-in [`display` function](./javascript#display(value)) explicitly. The above block defines the top-level variable `x` with a value of ${x}.

(A technical note: the parser first attempts to parse the input as an expression; if that fails, it parses it as a program. So, code such as `{foo: 1}` is interpreted as an object literal rather than a block with a labeled statement.)

### Inline expressions

Inline JavaScript expressions interpolate live values into Markdown. They are typically used to display dynamic numbers such as metrics, or to arrange visual elements such as charts into rich HTML layouts.

For example, this paragraph simulates rolling a 20-sided dice:

```md
You rolled ${Math.floor(Math.random() * 20) + 1}.
```

You rolled ${Math.floor(Math.random() * 20) + 1}. Reload the page to re-roll.

As with code blocks, if an inline expression evaluates to a DOM node, it will be displayed. For example, you can interpolate a sparkline ${Plot.plot({axis: null, margin: 0, width: 80, height: 17, x: {type: "band", round: false}, marks: [Plot.barY(aapl.slice(-15), {x: "Date", y1: 150, y2: "Close", fill: "steelblue"})]})} or even a reactive input ${Inputs.bind(htl.html`<input type=range style="width: 120px;">`, numberInput)} ${number} into prose.

```js
const numberInput = Inputs.input(0);
const number = Generators.input(numberInput);
```

Unlike code blocks, expressions cannot declare top-level variables.

## HTML in Markdown

You can write HTML directly into Markdown. HTML is useful for greater control over layout, say to use CSS grid for a responsive bento box layout in a dashboard, or adding an external stylesheet via a link element. For example, here is an HTML details element:

````html
<details>
  <summary>Click me</summary>
  This text is not visible by default.
</details>
````

This produces:

<details>
  <summary>Click me</summary>
  This text is not visible by default.
</details>

In Markdown, blank lines denote separate HTML blocks; be sure to avoid blank lines if you want to treat a chunk of HTML as a single block. For example, write this:

```md
<!-- 👍 one HTML block -->
<ul>
  <li>one</li>
  <li>two</li>
  <li>three</li>
</ul>
```

Don’t write this:

```md
<!-- 👎 three HTML blocks -->
<ul>

  <li>one</li>
  <li>two</li>
  <li>three</li>

</ul>
```

In the latter case, the li elements become top-level and wrapped in a span, rather than children of the ul.
