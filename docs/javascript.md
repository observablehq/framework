# JavaScript

[Observable Markdown](./markdown) supports JavaScript for interactive charts and other dynamic content. This client-side JavaScript runs in the browser on load, and re-runs automatically — and incrementally — when [reactive variables](./javascript/reactivity) change or when you edit pages during development.

JavaScript in Markdown can be expressed either as [fenced code blocks](#fenced-code-blocks) or [inline expressions](#inline-expressions). You can also write JavaScript modules alongside Markdown files and [import them](./javascript/imports) into Markdown. (And you can run JavaScript, TypeScript, Python, or any other programming language during build to generate data using [data loaders](./loaders).)

### Fenced code blocks

JavaScript fenced code blocks (<code>```js</code>) are typically used to [display content](./javascript/display) such as charts and inputs. They can also be used for logic by declaring top-level variables, say to load data or declare helper functions.

JavaScript blocks come in two forms: *expression* blocks and *program* blocks. An expression block looks like this (and note the lack of semicolon):

````md
```js
1 + 2
```
````

This produces:

```js
1 + 2
```

Note that JavaScript fenced code blocks do not echo their code by default. If you want to show the code, use the `echo` directive:

````md
```js echo
1 + 2
```
````

The code is displayed below the output, like so:

```js echo
1 + 2
```

If an expression evaluates to a DOM node, the node is displayed. For example, here is an SVG element generated by [Observable Plot](https://observablehq.com/plot):

````md
```js
Plot.lineY(aapl, {x: "Date", y: "Close"}).plot({y: {grid: true}})
```
````

This produces:

```js
Plot.lineY(aapl, {x: "Date", y: "Close"}).plot({y: {grid: true}})
```

A program block looks like this:

````md
```js
const x = 1 + 2;
```
````

```js
const x = 1 + 2;
```

A program block doesn’t display anything by default, but you can call the built-in [`display` function](./javascript/display) explicitly. The above block defines the top-level variable `x` with a value of ${x}.

(A technical note: the parser first attempts to parse the input as an expression; if that fails, it parses it as a program. So, code such as `{foo: 1}` is interpreted as an object literal rather than a block with a labeled statement.)

### Inline expressions

Inline JavaScript expressions (<code>$\{…}</code>) interpolate values into Markdown. They are typically used to display numbers such as metrics, or to arrange visual elements such as charts into rich HTML layouts. Like fenced code blocks, inline expressions automatically re-run when referenced reactive variables change, or when you edit the page during development.

For example, this paragraph simulates rolling a 20-sided dice:

```md
You rolled ${Math.floor(Math.random() * 20) + 1}.
```

You rolled ${Math.floor(Math.random() * 20) + 1}. (Reload the page to re-roll.)

And here’s an [button input](./lib/inputs) that counts clicks:

```js echo
const clicks = view(Inputs.button("Click me"));
```

```md
You clicked ${clicks.toLocaleString("en-US")} times.
```

You clicked ${clicks.toLocaleString("en-US")} times.

As with code blocks, if an inline expression evaluates to a DOM node, it will be displayed. For example, you can interpolate a sparkline ${Plot.plot({axis: null, margin: 0, width: 80, height: 17, x: {type: "band", round: false}, marks: [Plot.barY(aapl.slice(-15), {x: "Date", y1: 150, y2: "Close", fill: "steelblue"})]})} or even a reactive input ${Inputs.bind(htl.html`<input type=range style="width: 120px;">`, numberInput)} ${number} into prose.

```js
const numberInput = Inputs.input(0);
const number = Generators.input(numberInput);
```

Unlike code blocks, expressions cannot declare top-level reactive variables.
